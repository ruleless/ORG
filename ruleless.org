* Schedule
** Schedule For Job
*** 2015/10
**** DONE <2015-10-15 周四>(第二周) [100%]
	 CLOSED: [2015-10-17 周六 17:42]
	 - STATE "DONE"       FROM "PROCESSING" [2015-10-17 周六 17:42]
	 - STATE "PROCESSING" FROM "TODO"       [2015-10-16 周五 10:06]
***** DONE [[HTTP://172.16.0.150:81/ISSUES/15582][怪物装备掉率可调整功能支持]]
	  CLOSED: [2015-10-17 周六 17:42] DEADLINE: <2015-10-17 周六>
	  - STATE "DONE"       FROM "TODO"       [2015-10-17 周六 17:42]
***** DONE 技能心法1-50级引导界面
	  CLOSED: [2015-10-16 周五 16:33] DEADLINE: <2015-10-17 周六>
	  - STATE "DONE"       FROM "PROCESSING" [2015-10-16 周五 16:33]
	  - STATE "PROCESSING" FROM "TODO"       [2015-10-16 周五 10:47]
***** DONE [[HTTP://172.16.0.150:81/ISSUES/14921][首次出国任务警示和死亡引导]] [100%]
	  CLOSED: [2015-10-16 周五 16:00]
	  - STATE "DONE"       FROM "PROCESSING" [2015-10-16 周五 16:00]
	  - STATE "PROCESSING" FROM "DONE"       [2015-10-16 周五 10:07]
****** DONE 新手玩家首次被杀时，给与一定的补偿和安抚
	   CLOSED: [2015-10-16 周五 10:06]
	   - STATE "DONE"       FROM "PROCESSING" [2015-10-16 周五 10:06]
	   - STATE "PROCESSING" FROM "TODO"       [2015-10-15 周四 15:05]
****** DONE 新手玩家初次出国时，给予警示
	   CLOSED: [2015-10-16 周五 16:00]
	   - STATE "DONE"       FROM "PROCESSING" [2015-10-16 周五 16:00]
	   - STATE "PROCESSING" FROM "TODO"       [2015-10-16 周五 10:47]
**** DONE <2015-10-19 周一> [100%]
	 CLOSED: [2015-10-23 周五 16:58]
	 - STATE "DONE"       FROM "TODO"       [2015-10-23 周五 16:58]
***** DONE 伤害分析功能支持									   :SKILL:TRACER:
	  CLOSED: [2015-10-23 周五 16:58]
	  - STATE "DONE"       FROM "TODO"       [2015-10-23 周五 16:58]
	  #+BEGIN_SRC LUA
        FUNCTION TOGGLESKILLTIMETRACER()
            IF EXISTSKILLTIMETRACER() THEN
                CLOSESKILLTIMETRACER()
                GETCHATCLIENT():ADDSYSTEMTIPS(TIPTYPE_OPERATE, INFOPOS_ACTORRIGHT+INFOPOS_CHATWINDOW, "关闭技能时间追踪，请打开配表查询！")
            ELSE
                OPENSKILLTIMETRACER()
                GETCHATCLIENT():ADDSYSTEMTIPS(TIPTYPE_OPERATE, INFOPOS_ACTORRIGHT+INFOPOS_CHATWINDOW, "打开技能时间追踪！")
            END
        END
        TOGGLESKILLTIMETRACER()
	  #+END_SRC
***** DONE 实时直线碰撞型技能优化，并提供数值配置依据
	  CLOSED: [2015-10-23 周五 12:24]
	  - STATE "DONE"       FROM "TODO"       [2015-10-23 周五 12:24]
***** DONE 首次出国任务警示和死亡引导跟进优化
	  CLOSED: [2015-10-23 周五 09:52]
	  - STATE "DONE"       FROM "TODO"       [2015-10-23 周五 09:52]
***** DONE 怪物的技能也要支持配置：修正目标至最远点
	  CLOSED: [2015-10-23 周五 09:52]
	  - STATE "DONE"       FROM "TODO"       [2015-10-23 周五 09:52]
**** DONE <2015-10-26 周一> [100%]
	 CLOSED: [2015-11-03 周二 18:05]
	 - State "DONE"       from "TODO"       [2015-11-03 周二 18:05]
***** DONE OGAME微端服务器架设以及调通原有逻辑
	  CLOSED: [2015-11-02 周一 11:46]
	  - State "DONE"       from "PROCESSING" [2015-11-02 周一 11:46]
	  - STATE "PROCESSING" FROM "TODO"       [2015-10-26 周一 09:43]
***** DONE Request_QiChengDownHorse优化
	  CLOSED: [2015-10-28 周三 11:33]
	  - State "DONE"       from "TODO"       [2015-10-28 周三 11:33]
***** DONE 合服界面活动图标切页逻辑优化
	  CLOSED: [2015-10-28 周三 09:46]
	  - State "DONE"       from "TODO"       [2015-10-28 周三 09:46]
***** DONE 摆摊后台日志优化(针对转入日志添加顾客信息，针对转出日志添加摊主信息)；摆摊模块资源操作优化(修复一处刷资源隐患)
	  CLOSED: [2015-10-27 周二 19:42]
	  - State "DONE"       from "PROCESSING" [2015-10-27 周二 19:42]
	  - State "PROCESSING" from "TODO"       [2015-10-26 周一 18:27]
***** DONE 优化成就系统的七龙珠调试功能
	  CLOSED: [2015-10-26 周一 16:06]
	  - State "DONE"       from "TODO"       [2015-10-26 周一 16:06]
*** 2015/11
**** DONE <2015-11-02 周一> [50%]
	 CLOSED: [2015-11-23 周一 09:45]
	 - State "DONE"       from "TODO"       [2015-11-23 周一 09:45]
***** DONE OGame微客户端 [1/1]
	  CLOSED: [2015-11-23 周一 09:46]
	  - State "DONE"       from "TODO"       [2015-11-23 周一 09:46]
****** DONE 可异步下载资源整理
	   CLOSED: [2015-11-04 周三 16:01]
	   - State "DONE"       from "TODO"       [2015-11-04 周三 16:01]
**** DONE <2015-11-23 周一>
	 CLOSED: [2015-11-30 周一 09:28]
	 - State "DONE"       from "TODO"       [2015-11-30 周一 09:28]
***** DONE 微客户端打包工具
	  CLOSED: [2015-11-30 周一 09:28]
	  - State "DONE"       from "TODO"       [2015-11-30 周一 09:28]
**** DONE <2015-11-30 周一> [100%]
	 CLOSED: [2015-12-04 周五 17:10]
	 - State "DONE"       from "TODO"       [2015-12-04 周五 17:10]
***** DONE 技能周围心法槽特效在重新打开后不显示
	  CLOSED: [2015-12-04 周五 15:29]
	  - State "DONE"       from "TODO"       [2015-12-04 周五 15:29]
***** DONE 窗口加载卸载问题修复
	  CLOSED: [2015-12-04 周五 17:10]
	  - State "DONE"       from "TODO"       [2015-12-04 周五 17:10]
	  装备回收相关窗口；心法操作窗口未注册
***** DONE 微客户端打包工具
	  CLOSED: [2015-12-03 周四 10:21]
	  - State "DONE"       from "PROCESSING" [2015-12-03 周四 10:21]
	  - State "PROCESSING" from "TODO"       [2015-11-23 周一 09:48]
***** DONE 增加技能冷却中施放提示
	  CLOSED: [2015-12-01 周二 17:41]
	  - State "DONE"       from "TODO"       [2015-12-01 周二 17:41]
***** DONE 摆摊模块支持可用Lua脚本关闭
	  CLOSED: [2015-12-01 周二 17:14]
	  - State "DONE"       from "TODO"       [2015-12-01 周二 17:14]
***** DONE 基于CommonWindow的所有窗口托管给标准的窗口管理系统
	  CLOSED: [2015-12-01 周二 16:18]
	  - State "DONE"       from "TODO"       [2015-12-01 周二 16:18]
*** 2015/12
**** <2015-12-07 周一>
***** TODO 支持怪物出生动画调用技能轨迹系统
***** TODO 注册先前未注册管理器模块的窗口
***** TODO 微客户端后台下载策略优化
**** TODO 微客户端BUG修复 [1/3]
	 1. [X] 通过fileindex.csv推送的下载列表若出错，游戏是否还能正常显示
		结论：推送的列表出错不会引起逻辑错误，顶多浪费下带宽，报几个错误
	 2. [-] 有些资源不能通过网络异步加载
		1. [X] 音效资源
		2. [X] UI纹理资源
		3. [ ] 场景纹理资源
	 3. [ ] 道士蛊毒咒技能没有特效
*** Bug Trace
**** TODO 边境任务如果最后一轮是偷马任务，完成偷马后任务追踪里头偷马任务不消失。（偶尔）
*** TODO OGAME微端 [33%]
**** 微端原理及工作流程
	 * 文件云服务协议及工作过程简述:
	   1. 客户端连接到云服务器
	   2. 报告本地版本及本地已有文件ID列表
	   3. 服务器根据版本ID下发客户端需要重新更新的文件ID
	   4. 客户端将需要重新更新的文件删除同时修改版本号
	   5. 报告本地角色信息请求服务器智能调度预下载文件优先级
	   6. 本地正在请求的文件向服务器提交下载
	   7. 请求下载智能预下载队列中的文件
	   8. 下载成功后保存在本地文件索引表中
	   9. 上报文件请求响应情况采样给服务器供优化智能预下载算法
	 * 智能预下载算法补遗:
	   1. 正在请求的优先级最高
	   2. 文件小的优先级高
	   3. 访问次数多的优先级高
	   4. 内容重要的优先级高
	   5. 下载内容需要支持压缩
	   6. 本地需要保存为包态，并支持自动更新
	   7. 只下载当前地图可能用到的资源
	   8. 根据进入地图到用到该资源的TICK进行统计，优先下载相近时间点需要的资源
	   9. 按之前的评分进行下载，然后根据命中的效果对评分进行修正，例如30秒内用到则+10分,30-60秒用到+5分,5分钟内用到+1分
	   10. 由于基于HTTP访问，所以最好合并请求
	   11. 另外支持TCP专有协议请求，因为这样可以减少断开连接带来的损失，最好小文件TCP请求,大文件HTTP请求.2种做到无缝切换
	   12. 尝试建立文件关联性，如果某个文件被下载，则另外一个文件很可能被下载
	   13. 文件数据库存储在服务端，每次从服务器下载最新文件数据库
	   14. 支持多线程下载
	   15. TCP管道每天保存一定数量的请求采样，数据挖掘程序在后台定时分析作业
	   16. 需要同步下载的文件不能从网上下载，FB文件都要改成异步加载
	   17. 前期任务速度需要减慢速度，以赢得下载时间
	   18. 服务器上存储包文件好还是存储散文件好？
**** 微客户端操作指引
***** 微客户端服务器部署
****** 基于Http协议的资源服务器
******* 外网 #<<http_resaddr>>
		外网的资源服务器地址通过CDN提供商获得，我们只需将CDN提供商提供的地址填入配置文件即可：
		#+begin_src html
          [Cloud]
          back_list=recomments.int
          resource_1=http://localhost # 地址1
          resource_2=http://localhost # 地址2

          [setting]
          open=1
          enablerecommend=1
          enable_check=0
          cloud_1=127.0.0.1:9381
		#+end_src
		文件名：cloud_config.ini，放置到云服务器目录（虽然客户端也有该文件，但资源地址实际是通过云服务器获得的）。

		哪些资源需要提交给CDN？工具 FileCloudIndex.exe 生成的所有zip压缩文件。
******* 内网
		内网需要我们自己搭建Web服务器，过程不予赘述。其他同外网。
****** 云服务器(FileCloud.exe)
******* 云服务器所提供的服务
		1. 微客户端更新管理 #<<changelog>>
		   服务器目录有一个名为changelog.xml的文件，其内容形如：
		   #+begin_src html
             <changelog>
               <version ver=1>
                 <file id=1541545 /> # id 在 fileindex.csv 中查找
                 <file id=1541543 /> # id 在 fileindex.csv 中查找
               </version>
               <version ver=2>
                 <file id=1541545 /> # id 在 fileindex.csv 中查找
                 <file id=1541543 /> # id 在 fileindex.csv 中查找
               </version>
               <version ver=3>
                 <file id=1541545 /> # id 在 fileindex.csv 中查找
                 <file id=1541543 /> # id 在 fileindex.csv 中查找
               </version>
             </changelog>
		   #+end_src
		   需要更新的文件将由服务器发送到微客户端，然后微客户端将删除所有需要更新的文件，然后重新下载(不是马上)。
		2. 提供资源服务器地址

		   已在[[http_resaddr]]处说明。
		3. 智能下载列表推送

		   微客户端云服务器能够根据资源关联地图以及资源下载次数等相关参数动态地推送下载列表。一般来说微客户端玩家越多推送越精准、越及时。

		   此功能需要将 FileCloudIndex.exe 工具生成的 fileindex.csv 文件放置到服务器目录下。
		4. 静态下载列表推送 #<<recomments>>

		   静态下载列表推送作为第3条功能的补充，将固定地推送 recomments.csv 配置表中的文件。recomments.csv 中的内容形如：
		   #+begin_src html
             文件名,
             string,
             Scene\Maps\4505\18_22.jpg,
             Scene\Maps\4503\15_5.jpg,
             UI\layout\GroupUI.layout,
             Scene\Maps\104\2_5.jpg,
             Scp\Wing.csv,
             Effect\WingEFFect\wing_keai\keai_01\chibang_01_guangyun.pts,
             Scene\Maps\102\6_7.jpg,
		   #+end_src
		5. 备用下载源

		   当无法通过http协议从CDN服务器上下载资源时，微客户端将尝试从云服务器下载。
******* 云服务器配置文件
		1. cloud_config.ini 基础配置，客户端和服务器各放置一份。
		2. changelog.xml 只放置在服务器目录，用于微客户端资源更新管理。见[[changelog]]。
		3. fileindex.csv 由FileCloudIndex.exe工具生成，客户端也有一份同名的配置文件，但客户端的该文件内容可为空。
		4. recomments.csv 只放置在服务器目录，用于存放静态推送列表。见[[recomments]]
		5. verifylist.xml 只放置在服务器目录，用于文件校验。其内容形如：
		   #+begin_src html
             <filelist>
               <file id=1541545 /> # id 在 fileindex.csv 中查找
               <file id=1541543 /> # id 在 fileindex.csv 中查找
             </filelist>
		   #+end_src
		   对于比较重要的文件可在此处填入其文件ID进行校验。
****** 微客户端文件压缩 (工具:FileCloudIndex.exe)
	   此工具遍历客户端资源目录([客户端根目录]/Data/)，加密并压缩该目录下的每一个文件(保存为[原文件名].zip)。最后还将会生成fileindex.csv文件。

	   此工具生成的所有压缩文件为微客户端下载源，可通过Http(CDN)或Tcp(云服务器)协议下载。

	   FileCloudIndex.exe工具指定的资源目录必须配置到Http服务器和云服务器中。
***** 客户端配置文件
	  1. cloud_config.ini 各配置项说明如下：
		 #+begin_src html
		   [Cloud]
		   back_list=recomments.csv # 存放静态推送列表的文件
		   resource_1=http://localhost # CDN地址1
		   resource_2=http://localhost # CDN地址2

		   [setting]
		   open=1 # 是否开启微客户端模式
		   enablerecommend=1
		   enable_check=0
		   cloud_1=127.0.0.1:9381 # 云服务器地址1
		   cloud_1=127.0.0.1:9381 # 云服务器地址1
		 #+end_src
	  2. fileindex.csv 可配置为空，形如：
		 #+begin_src html
		   ID,路径,大小,下载次数,重要度,引用地图1,引用地图2,引用地图3,引用地图4,引用地图5,引用地图6,引用地图7,引用地图8
		   int,string,int,int,int,int,int,int,int,int,int,int,int
		 #+end_src
***** 服务器部署以及客户端打包步骤
****** 服务器部署步骤
	   1. 打开FileCloudIndex.exe，选择资源目录(建议单独签出客户端Data目录)，点击生成。
	   2. 在cloud_config.ini文件中填入资源下载地址，形如：
		  #+begin_src html
            resource_1=http://localhost
		  #+end_src
		  之后，需将FileCloudIndex.exe指定的资源目录配置为Http协议可访问模式。在外网时，将资源提交给CDN提供商即可；在内网时，可通过Appache配置。
	   3. 在cloud_config.ini文件中填入云服务器IP地址，形如：
		  #+begin_src html
            cloud_1=127.0.0.1:9381
		  #+end_src
	   4. 打开FileCloud.exe，选择资源目录，点击Start按钮，若提示：[1123 10:22:15] ERROR: 启动成功...，则表示云服务器启动成功。
****** 客户端打包
	   1. 将mcmd.py和mclient.py文件拷贝到客户端Data目录，运行mcmd.py，选择"2. 移除非微端资源"。另外，建议单独签出整个客户端目录，作为每次微客户端打包的目录。
	   2. 将cloud_config.ini文件和fileindex.csv文件(可不填任何具体文件)拷贝至客户端Bin目录
	   3. 进入打包流程(与大端一致)。
**** TODO 微端体验优化
***** 重要资源排序
	  1. 主角动画
	  2. 怪物动画
	  3. 地表资源(若没有，在某些地方会悬空)
	  4. UI资源
	  5. 环境资源(花花草草)
**** TODO 微客户端资源后台下载
	 * 智能下载列表推送
	   服务器可根据玩家所处地图智能推荐后台下载资源列表。工作流程如下：
	   1. 各微客户端跑图时，定时上传资源采样信息；服务器会根据采样信息动态调整资源的关联地图以及优先级等。
	   2. 微客户端跑图时，定时向服务器请求推荐列表。
	 * 静态推荐下载列表
**** TODO 微客户端更新管理
**** DONE 微客户端可异步加载的资源 [7/7]
	 CLOSED: [2015-11-04 周三 15:11]
	 - State "DONE"       from "TODO"       [2015-11-04 周三 15:11]
	 1. [X] UI/ [4/4]
		本目录存放游戏界面所需的图片以及特效资源。
		1. [X] UI/Image/
	       远征遗留下来的旧UI资源目录，现在仍有部分图片资源在该目录下。
		   此目录下的所有资源均可异步加载。
		2. [X] UI/image_New/
		   可异步加载
		3. [X] UI/bg/
		   登陆、角色选取以及场景切换需使用到的大背景图存放于此目录。
		   * 登陆及角色选取背景图片由于是直接在逻辑层引用图片路径，未走文件系统逻辑，所以无法异步加载
		   * 场景切换背景图片在资源缺失时通常需要在完成场景切换后才会走完异步加载流程，原因待查
		4. [X] UI/effect/
		   此目录用于存放UI序列帧动画相应的图片资源，例如技能冷却转圈动画。
		   此目录下的所有资源均可异步加载。
	 2. [X] Models/
		此目录存放怪物、主角以及载具的模型、贴图和动画文件。可异步加载。
	 3. [X] Effect/ [10/10]
		不败传说特效资源目录，主要包含三类文件：模型文件(.Mz, .mzlod)，模型贴图文件(.dds)，粒子(.pts)。
		除了.skilleffects技能配置文件和.mzlod文件之外，该目录下的其余文件均可异步加载。
		1. [X] Effect/ActorSkillEffect/
		   技能特效资源目录，除在技能编辑器中引用到特效资源之外还包含技能升级特效资源。另外.skilleffects格式的文件为配置文件，不可异步加载。
		2. [X] Effect/CommonEffect/
		   Buff和其他功能模块所引用的特效资源存放于此目录。
		3. [X] Effect/D3_sourceimages/
		4. [X] Effect/EquipmentFlash/
		   装备发光特效资源目录。
		5. [X] Effect/MonsterEffect/
		6. [X] Effect/NPCEffect/
		7. [X] Effect/SceneEffect/
		   场景相关的特效资源目录。
		8. [X] Effect/textures/
		   模型贴图资源目录。
		9. [X] Effect/UiEffect/
		   UI特效资源目录。
		10. [X] Effect/WingEFFect/
			翅膀特效资源目录。
	 4. [X] Creature/
		远征遗留的特效资源目录。
		可异步加载。
	 5. [X] Scene/
		游戏场景相关的资源存放在此目录。
		1. [X] Scene/Grass/
		   地表植被贴图资源。当前不可异步加载。
		2. [X] Scene/Maps/
		   此目录存放：mps文件、terrain文件以及切块后的小地图图片文件(jpg格式)。mps及terrain文件不可异步加载，jpg可以异步加载。
		3. [X] Scene/Model/
		   场景物件模型资源目录。有BUG，需调试
		4. [X] Scene/Texture/
		   地表贴图。当前不可异步加载。
	 6. [X] Music/
		音频资源文件可异步加载。
	 7. [X] Environment/
		环境相关的资源目录。只有此目录下的模型和贴图文件才可异步加载。
**** DONE 微客户端必须资源    总大小:541 MB
	 CLOSED: [2015-11-05 周四 09:45]
	 - State "DONE"       from "TODO"       [2015-11-05 周四 09:45]
	 1. Scene/           361 MB
		1. Scene/Model/    258 MB
		   此文件下的 mz 文件全部予以保留，模型贴图和动画文件异步下载。

		   mz 文件必须保留的原因是：游戏场景中很多地表是直接铺的模型（如：王城、逍遥城），所以模型的碰撞信息需同步加载，而模型的碰撞信息当前是保存在 mz 文件中的。
		2. Scene/Maps/    62.5 MB
		   保留terrain 和 mps 文件
		3. Scene/Texture/    39.8 MB
		   地表纹理贴图，当前不支持异步加载，个人认为也不需异步加载！
	 2. UI/              51.4 MB
		除了背景图片资源之外(16.5 MB)，其余图片和模型资源全部异步下载
	 3. Video/           47.2 MB
		全部保留
	 4. Scp/             31.0 MB
		全部保留
	 5. Fonts/           29.00 MB
		此目录全部保留
	 6. Effect/          7.83 MB
		需保留：技能配置文件(.skilleffects)，细节层次优化文件(.mzlog)
	 7. Shader/          4.96 MB
		全部保留
	 8. Lightmap/        1.33 MB
		此目录全部保留
	 9. Helper/          1.38 MB
		此目录全部保留
	 10. Models/         224 KB
		 角色武器模型的mzlod文件
	 11. Environment/    58.2 KB
		 需保留：env格式的文本配置文件
** Schedule For Career
*** 2015/10
**** DONE <2015-10-16 周五> [100%]
	 CLOSED: [2015-10-20 周二 09:42]
	 - STATE "DONE"       FROM "TODO"       [2015-10-20 周二 09:42]
***** DONE Learned About Emacs Org-Mode
	  CLOSED: [2015-10-19 周一 19:55]
	  - STATE "DONE"       FROM "TODO"       [2015-10-19 周一 19:55]
**** DONE <2015-10-19 周一> [100%]
	 CLOSED: [2015-11-02 周一 11:54]
	 - State "DONE"       from "TODO"       [2015-11-02 周一 11:54]
***** DONE 针对编程语言设计的一些浅显思考
	  CLOSED: [2015-11-02 周一 11:55]
	  - State "DONE"       from "TODO"       [2015-11-02 周一 11:55]
      1. 计算机是图灵机，图灵机是现代命令式编程语言的理论基础。
      2. 数理逻辑是计算机科学相当重要的理论学科
	  3. 数理逻辑包含二演算、四论：命题逻辑演算、谓词逻辑演算；模型论、递归论、证明论、集合论。
*** 2015/11
**** DONE <2015-11-02 周一> [100%]
	 CLOSED: [2015-11-23 周一 09:51]
	 - State "DONE"       from "TODO"       [2015-11-23 周一 09:51]
***** DONE 线程池技术
	  CLOSED: [2015-11-04 周三 09:24]
	  - State "DONE"       from "TODO"       [2015-11-04 周三 09:24]
**** DONE <2015-11-23 周一> do nothing.
	 CLOSED: [2015-11-30 周一 09:30]
	 - State "DONE"       from "TODO"       [2015-11-30 周一 09:30]
**** DONE <2015-11-30 周一> [100%]
	 CLOSED: [2015-12-06 周日 22:24]
	 - State "DONE"       from "TODO"       [2015-12-06 周日 22:24]
***** DONE 安装 CentOS 后的系统配置及软件安装备忘
	  CLOSED: [2015-12-06 周日 22:24]
	  - State "DONE"       from "TODO"       [2015-12-06 周日 22:24]
*** 2015/12
**** <2015-12-07 周一>
***** TODO 数理逻辑部分
**** PROCESSING 日志系统实现
	  - State "PROCESSING" from "TODO"       [2015-11-23 周一 09:52]
**** PROCESSING [[LINK_QUATERNION][四元数]]
	 - STATE "PROCESSING" FROM "TODO"       [2015-10-19 周一 19:56]
**** TODO 无锁队列
**** TODO skynet消息队列同步操作方式
**** TODO [[LINK_KBE_STARTUP][KBE启动和执行流程]]
**** TODO AI [0%]
	 * [ ] [[http://www.cnblogs.com/fingerpass/p/discussion-about-game-ai.html][漫谈游戏中的人工智能]]
     * [ ] 决策树
	 * [ ] 行为树
	   腾讯开源行为树实现 https://github.com/ruleless/behaviac
** Summary
*** Be Skilled In
	* 擅长基于Unix平台的应用开发
	* 熟悉中心拓扑结构的MMOG服务器架构
*** Work Exp
**** OG
	 * 技能模块设计和实现
* Notes
** GAE(GOOGLE APP ENGINE)
** Apache
*** Apache的配置文件http.conf参数含义详解
**** 基本配置
	 #+begin_src sh
       ServerRoot "/mnt/software/apache2" #你的apache软件安装的位置。其它指定的目录如果没有指定绝对路径，则目录是相对于该目录。
       PidFile logs/httpd.pid #第一个httpd进程(所有其他进程的父进程)的进程号文件位置。
       Listen 80 #服务器监听的端口号。
       ServerName www.clusting.com:80 #主站点名称（网站的主机名）。
       ServerAdmin admin@clusting.com #管理员的邮件地址。
       DocumentRoot "/mnt/web/clusting" #主站点的网页存储位置。
	 #+end_src
	 目录访问控制配置
	 #+begin_src html
       <Directory "D:/xampp/cgi-bin">
         Options FollowSymLinks
         AllowOverride None
         Order allow,deny
         Allow from all
       </Directory>
	 #+end_src
	 在上面这段目录属性配置中，主要有下面的选项：
	 1. Options：配置在特定目录使用哪些特性，常用的值和基本含义如下：
	    1. ExecCGI: 在该目录下允许执行CGI脚本。
		2. FollowSymLinks: 在该目录下允许文件系统使用符号连接。
		3. Indexes: 当用户访问该目录时，如果用户找不到DirectoryIndex指定的主页文件(例如index.html),则返回该目录下的文件列表给用户。
		4. SymLinksIfOwnerMatch: 当使用符号连接时，只有当符号连接的文件拥有者与实际文件的拥有者相同时才可以访问。
	    其它可用值和含义请参阅：http://www.clusting.com/Apache/ApacheManual/mod/core.html#options
	 2. AllowOverride：允许存在于.htaccess文件中的指令类型(.htaccess文件名是可以改变的，其文件名由AccessFileName指令决定)：
	    1. None: 当AllowOverride被设置为None时。不搜索该目录下的.htaccess文件（可以减小服务器开销）。
		2. All: 在.htaccess文件中可以使用所有的指令。
	    其他的可用值及含义(如：Options FileInfo AuthConfig Limit等)，请参看： http://www.clusting.com/Apache/ApacheManual/mod/core.html#AllowOverride
	 3. Order：控制在访问时Allow和Deny两个访问规则哪个优先：
		1. Allow：允许访问的主机列表(可用域名或子网，例如：Allow from 192.168.0.0/16)。
		2. Deny：拒绝访问的主机列表。
	    更详细的用法可参看：http://www.clusting.com/Apache/ApacheManual/mod/mod_access.html#order
	 #+begin_src sh
       DirectoryIndex index.html index.htm index.PHP #主页文件的设置（本例将主页文件设置为：index.html,index.htm和index.php）
	 #+end_src
**** 服务器的优化 (MPM: Multi-Processing Modules)
	 apache2主要的优势就是对多处理器的支持更好，在编译时同过使用Cwith-mpm选项来决定apache2的工作模式。如果知道当前的apache2使用什么工作机制，可以通过httpd -l命令列出apache的所有模块，就可以知道其工作方式：
	 * prefork：如果httpd -l列出prefork.c，则需要对下面的段进行配置：
	   1. StartServers 5 #启动apache时启动的httpd进程个数。
	   2. MinSpareServers 5 #服务器保持的最小空闲进程数。
	   3. MaxSpareServers 10 #服务器保持的最大空闲进程数。
	   4. MaxClients 150 #最大并发连接数。
	   5. MaxRequestsPerChild 1000 #每个子进程被请求服务多少次后被kill掉。0表示不限制，推荐设置为1000。
	   在该工作模式下，服务器启动后起动5个httpd进程(加父进程共6个，通过ps -ax|grep httpd命令可以看到)。当有用户连接时，apache会使用一个空闲进程为该连接服务，同时父进程会fork一个子进程。直到内存中的空闲进程达到 MaxSpareServers。该模式是为了兼容一些旧版本的程序。我缺省编译时的选项。
	 * worker：如果httpd -l列出worker.c，则需要对下面的段进行配置：
	   1. StartServers 2 #启动apache时启动的httpd进程个数。
	   2. MaxClients 150 #最大并发连接数。
	   3. MinSpareThreads 25 #服务器保持的最小空闲线程数。
	   4. MaxSpareThreads 75 #服务器保持的最大空闲线程数。
	   5. ThreadsPerChild 25 #每个子进程的产生的线程数。
	   6. MaxRequestsPerChild 0 #每个子进程被请求服务多少次后被kill掉。0表示不限制，推荐设置为1000。
	   该模式是由线程来监听客户的连接。当有新客户连接时，由其中的一个空闲线程接受连接。服务器在启动时启动两个进程，每个进程产生的线程数是固定的 (ThreadsPerChild决定)，因此启动时有50个线程。当50个线程不够用时，服务器自动fork一个进程，再产生25个线程。
	 * perchild：如果httpd -l列出perchild.c，则需要对下面的段进行配置：
	   1. NumServers 5 #服务器启动时启动的子进程数
	   2. StartThreads 5 #每个子进程启动时启动的线程数
	   3. MinSpareThreads 5 #内存中的最小空闲线程数
	   4. MaxSpareThreads 10 #最大空闲线程数
	   5. MaxThreadsPerChild 2000 #每个线程最多被请求多少次后退出。0不受限制。
	   6. MaxRequestsPerChild 10000 #每个子进程服务多少次后被重新fork。0表示不受限制。
	   该模式下，子进程的数量是固定的，线程数不受限制。当客户端连接到服务器时，又空闲的线程提供服务。 如果空闲线程数不够，子进程自动产生线程来为新的连接服务。该模式用于多站点服务器。
**** HTTP返回头信息配置
	 * ServerTokens Prod #该参数设置http头部返回的apache版本信息，可用的值和含义如下：
	   1. Prod：仅软件名称，例如：apache
	   2. Major：包括主版本号，例如：apache/2
	   3. Minor：包括次版本号，例如：apache/2.0
	   4. Min：仅apache的完整版本号，例如：apache/2.0.54
	   5. OS：包括操作系统类型，例如：apache/2.0.54（Unix）
	   6. Full：包括apache支持的模块及模块版本号，例如：Apache/2.0.54 (Unix) mod_ssl/2.0.54 OpenSSL/0.9.7g
	 * ServerSignature Off #在页面产生错误时是否出现服务器版本信息。推荐设置为Off
**** 持久性连接设置
	 * KeepAlive On #开启持久性连接功能。即当客户端连接到服务器，下载完数据后仍然保持连接状态。
	 * MaxKeepAliveRequests 100 #一个连接服务的最多请求次数。
	 * KeepAliveTimeout 30 #持续连接多长时间，该连接没有再请求数据，则断开该连接。缺省为15秒。
**** 别名设置
	 对于不在DocumentRoot指定的目录内的页面，既可以使用符号连接，也可以使用别名。别名的设置如下：
	 #+begin_src html
       Alias /download/ "/var/www/download/" #访问时可以输入:http://www.custing.com/download/
       #对该目录进行访问控制设置
       Options Indexes MultiViews
       AllowOverride AuthConfig
       Order allow,deny
       Allow from all
	 #+end_src
**** CGI设置
	 #+begin_src html
       scrīptAlias /cgi-bin/ "/mnt/software/apache2/cgi-bin/" # 访问时可以：http://www.clusting.com/cgi-bin/ 。但是该目录下的CGI脚本文件要加可执行权限！

       #设置目录属性
       AllowOverride None
       Options None
       Order allow,deny
       Allow from all
	 #+end_src
**** 日志的设置
	 * 错误日志的设置
	   #+begin_src sh
         ErrorLog logs/error_log #日志的保存位置
         LogLevel warn #日志的级别
	   #+end_src
	   显示的格式如下
	   #+begin_src html
         [Mon Oct 10 15:54:29 2005] [error] [client 192.168.10.22] access to /download/ failed, reason: user admin not allowed access
	   #+end_src
	 * 日志格式设置
	   日志的缺省格式有如下几种：
	   #+begin_src html
         LogFormat "%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-Agent}i"" combined
         LogFormat "%h %l %u %t "%r" %>s %b" common #common为日志格式名称
         LogFormat "%{Referer}i -> %U" referer
         LogFormat "%{User-agent}i" agent
         CustomLog logs/access_log common
	   #+end_src
	   格式中的各个参数如下：
	   #+begin_src html
         %h C客户端的ip地址或主机名
         %l CThe 这是由客户端 identd 判断的RFC 1413身份，输出中的符号 "-" 表示此处信息无效。
         %u C由HTTP认证系统得到的访问该网页的客户名。有认证时才有效，输出中的符号 "-" 表示此处信息无效。
         %t C服务器完成对请求的处理时的时间。
         "%r" C引号中是客户发出的包含了许多有用信息的请求内容。
         %>s C这个是服务器返回给客户端的状态码。
         %b C最后这项是返回给客户端的不包括响应头的字节数。
         "%{Referer}i" C此项指明了该请求是从被哪个网页提交过来的。
         "%{User-Agent}i" C此项是客户浏览器提供的浏览器识别信息。
	   #+end_src
	   下面是一段访问日志的实例：
	   #+begin_src html
         192.168.10.22 C bearzhang [10/Oct/2005:16:53:06 +0800] "GET /download/ HTTP/1.1" 200 1228
         192.168.10.22 C - [10/Oct/2005:16:53:06 +0800] "GET /icons/blank.gif HTTP/1.1" 304 -
         192.168.10.22 C - [10/Oct/2005:16:53:06 +0800] "GET /icons/back.gif HTTP/1.1" 304 -
	   #+end_src
**** 虚拟主机的配置
	 * 基于IP地址的虚拟主机配置
	   #+begin_src html
         Listen 80

         DocumentRoot /www/example1
         ServerName www.example1.com

         DocumentRoot /www/example2
         ServerName www.example2.org
	   #+end_src
	 * 基于IP和多端口的虚拟主机配置
	   #+begin_src html
         Listen 172.20.30.40:80
         Listen 172.20.30.40:8080
         Listen 172.20.30.50:80
         Listen 172.20.30.50:8080

         DocumentRoot /www/example1-80
         ServerName www.example1.com

         DocumentRoot /www/example1-8080
         ServerName www.example1.com

         DocumentRoot /www/example2-80
         ServerName www.example1.org

         DocumentRoot /www/example2-8080
         ServerName www.example2.org
	   #+end_src
	 * 单个IP地址的服务器上基于域名的虚拟主机配置
	   #+begin_src html
         # Ensure that Apache listens on port 80
         Listen 80

         # Listen for virtual host requests on all IP addresses
         NameVirtualHost *:80

         DocumentRoot /www/example1
         ServerName www.example1.com
         ServerAlias example1.com. *.example1.com
         # Other directives here

         DocumentRoot /www/example2
         ServerName www.example2.org
         # Other directives here
	   #+end_src
	 * 在多个IP地址的服务器上配置基于域名的虚拟主机：
	   #+begin_src html
         Listen 80

         # This is the "main" server running on 172.20.30.40
         ServerName server.domain.com
         DocumentRoot /www/mainserver

         # This is the other address
         NameVirtualHost 172.20.30.50

         DocumentRoot /www/example1
         ServerName www.example1.com
         # Other directives here …

         DocumentRoot /www/example2
         ServerName www.example2.org
         # Other directives here …
	   #+end_src
	 * 在不同的端口上运行不同的站点(基于多端口的服务器上配置基于域名的虚拟主机)
	   #+begin_src html
         Listen 80
         Listen 8080

         NameVirtualHost 172.20.30.40:80
         NameVirtualHost 172.20.30.40:8080

         ServerName www.example1.com
         DocumentRoot /www/domain-80

         ServerName www.example1.com
         DocumentRoot /www/domain-8080

         ServerName www.example2.org
         DocumentRoot /www/otherdomain-80

         ServerName www.example2.org
         DocumentRoot /www/otherdomain-8080
	   #+end_src
	 * 基于域名和基于IP的混合虚拟主机的配置
	   #+begin_src html
         Listen 80

         NameVirtualHost 172.20.30.40

         DocumentRoot /www/example1
         ServerName www.example1.com

         DocumentRoot /www/example2
         ServerName www.example2.org

         DocumentRoot /www/example3
         ServerName www.example3.net
	   #+end_src
** Programming Language
*** 命令式编程
	C/C++、Lua、Python等都是实现此类编程方式的典范。采用命令式编程，我们需要告诉计算机每步的详细操作（即指令），在编程过程中，我们不仅需要知道问题是什么，更需要专注于怎么做才能得到我们想要的结果。
	早期的命令式编程语言都是电脑本身的机械语言。在这些语言中，指示非常简单，令硬件的运行更容易，却阻碍了复杂程序的设计。1954年开始开发的FORTRAN，是首个在复杂程序的设计中除掉机器码的编程语言。它是编译型的编程语言，容许命名变数、复杂的表达式、副程序和其他功能，这些功能现在在指令式语言中都非常普遍。后来的二十年中，可以看到大量的其他高级命令式编程语言出现。在1980年后，面向对象编程有迅速的发展，面向对象编程语言均有着指令式的风格，但增添了支持对象的功能。
**** 命令式编程语言所包含的
*** 声明式编程
	Prolog、SQL属于声明式编程范畴。采用声明式编程，我们只需向计算机描述我们的问题，而无须关注问题求解过程！
*** 为什么Lisp语言如此先进
	* 如果我们把流行的编程语言，以这样的顺序排列：Java、Perl、Python、Ruby。你会发现，排在越后面的语言，越像Lisp。Python模仿Lisp，甚至把许多Lisp黑客认为属于设计错误的功能，也一起模仿了。至于Ruby，如果回到1975年，你声称它是一种Lisp方言，没有人会反对。编程语言现在的发展，不过刚刚赶上1958年Lisp语言的水平。
   	* 1958年，John McCarthy设计了Lisp语言。我认为，当前最新潮的编程语言，只是实现了他在1958年的设想而已。这怎么可能呢？计算机技术的发展，不是日新月异吗？1958年的技术，怎么可能超过今天的水平呢？让我告诉你原因。这是因为John McCarthy本来没打算把Lisp设计成编程语言，至少不是我们现在意义上的编程语言。他的原意只是想做一种理论演算，用更简洁的方式定义图灵机。
   	  所以，为什么上个世纪50年代的编程语言，到现在还没有过时？简单说，因为这种语言本质上不是一种技术，而是数学。数学是不会过时的。你不应该把Lisp语言与50年代的硬件联系在一起，而是应该把它与快速排序（Quicksort）算法进行类比。这种算法是1960年提出的，至今仍然是最快的通用排序方法。
   	* Fortran语言也是上个世纪50年代出现的，并且一直使用至今。它代表了语言设计的一种完全不同的方向。Lisp是无意中从纯理论发展为编程语言，而Fortran从一开始就是作为编程语言设计出来的。但是，今天我们把Lisp看成高级语言，而把Fortran看成一种相当低层次的语言。
   	  1956年，Fortran刚诞生的时候，叫做Fortran I，与今天的Fortran语言差别极大。Fortran I实际上是汇编语言加上数学，在某些方面，还不如今天的汇编语言强大。比如，它不支持子程序，只有分支跳转结构（branch）。
   	  Lisp和Fortran代表了编程语言发展的两大方向。前者的基础是数学，后者的基础是硬件架构。从那时起，这两大方向一直在互相靠拢。Lisp刚设计出来的时候，就很强大，接下来的二十年，它提高了自己的运行速度。而那些所谓的主流语言，把更快的运行速度作为设计的出发点，然后再用超过四十年的时间，一步步变得更强大。
   	  直到今天，最高级的主流语言，也只是刚刚接近Lisp的水平。虽然已经很接近了，但还是没有Lisp那样强大。
   	* Lisp语言诞生的时候，就包含了9种新思想。其中一些我们今天已经习以为常，另一些则刚刚在其他高级语言中出现，至今还有2种是Lisp独有的。按照被大众接受的程度，这9种思想依次是：
	  1. 条件结构（即"if-then-else"结构）。现在大家都觉得这是理所当然的，但是Fortran I就没有这个结构，它只有基于底层机器指令的goto结构。
	  2. 函数也是一种数据类型。在Lisp语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够储存在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。
	  3. 递归。Lisp是第一种支持递归函数的高级语言。
	  4. 变量的动态类型。在Lisp语言中，所有变量实际上都是指针，所指向的值有类型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。
	  5. 垃圾回收机制。
	  6. 程序由表达式（expression）组成。Lisp程序是一些表达式区块的集合，每个表达式都返回一个值。这与Fortran和大多数后来的语言都截然不同，它们的程序由表达式和语句（statement）组成。
	     区分表达式和语句，在Fortran I中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，因为否则就无法处理这个值。
   	     后来，新的编程语言支持区块结构（block），这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从Fortran扩散到Algol语言，接着又扩散到它们两者的后继语言。
	  7. 符号（symbol）类型。符号实际上是一种指针，指向储存在哈希表中的字符串。所以，比较两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。
	  8. 代码使用符号和常量组成的树形表示法（notation）。
	  9. 无论什么时候，整个语言都是可用的。Lisp并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码；也可以在编译期读取或运行代码；还可以在运行期读取或者编译代码。
	     在读取期运行代码，使得用户可以重新调整（reprogram）Lisp的语法；在编译期运行代码，则是Lisp宏的工作基础；在运行期编译代码，使得Lisp可以在Emacs这样的程序中，充当扩展语言（extension language）；在运行期读取代码，使得程序之间可以用S-表达式（S-expression）通信，近来XML格式的出现使得这个概念被重新"发明"出来了。
   	* Lisp语言刚出现的时候，它的思想与其他编程语言大相径庭。后者的设计思想主要由50年代后期的硬件决定。随着时间流逝，流行的编程语言不断更新换代，语言设计思想逐渐向Lisp靠拢。
	  思想1到思想5已经被广泛接受，思想6开始在主流编程语言中出现，思想7在Python语言中有所实现，不过似乎没有专用的语法。思想8可能是最有意思的一点，它与思想9只是由于偶然原因，才成为Lisp语言的一部分，因为它们不属于John McCarthy的原始构想，是由他的学生Steve Russell自行添加的。它们从此使得Lisp看上去很古怪，但也成为了这种语言最独一无二的特点。Lisp古怪的形式，倒不是因为它的语法很古怪，而是因为它根本没有语法，程序直接以解析树（parse tree）的形式表达出来。在其他语言中，这种形式只是经过解析在后台产生，但是Lisp直接采用它作为表达形式。它由列表构成，而列表则是Lisp的基本数据结构。
	  用一门语言自己的数据结构来表达该语言，这被证明是非常强大的功能。思想8和思想9，意味着你可以写出一种能够自己编程的程序。这可能听起来很怪异，但是对于Lisp语言却是再普通不过。最常用的做法就是使用宏。
   	  术语"宏"在Lisp语言中，与其他语言中的意思不一样。Lisp宏无所不包，它既可能是某样表达式的缩略形式，也可能是一种新语言的编译器。如果你想真正地理解Lisp语言，或者想拓宽你的编程视野，那么你必须学习宏。
   	  就我所知，宏（采用Lisp语言的定义）目前仍然是Lisp独有的。一个原因是为了使用宏，你大概不得不让你的语言看上去像Lisp一样古怪。另一个可能的原因是，如果你想为自己的语言添上这种终极武器，你从此就不能声称自己发明了新语言，只能说发明了一种Lisp的新方言。
   	  我把这件事当作笑话说出来，但是事实就是如此。如果你创造了一种新语言，其中有car、cdr、cons、quote、cond、atom、eq这样的功能，还有一种把函数写成列表的表示方法，那么在它们的基础上，你完全可以推导出Lisp语言的所有其他部分。事实上，Lisp语言就是这样定义的，John McCarthy把语言设计成这个样子，就是为了让这种推导成为可能。
	* 就算Lisp确实代表了目前主流编程语言不断靠近的一个方向，这是否意味着你就应该用它编程呢？
      如果使用一种不那么强大的语言，你又会有多少损失呢？有时不采用最尖端的技术，不也是一种明智的选择吗？这么多人使用主流编程语言，这本身不也说明那些语言有可取之处吗？
   	  另一方面，选择哪一种编程语言，许多项目是无所谓的，反正不同的语言都能完成工作。一般来说，条件越苛刻的项目，强大的编程语言就越能发挥作用。但是，无数的项目根本没有苛刻条件的限制。大多数的编程任务，可能只要写一些很小的程序，然后用胶水语言把这些小程序连起来就行了。你可以用自己熟悉的编程语言，或者用对于特定项目来说有着最强大函数库的语言，来写这些小程序。如果你只是需要在Windows应用程序之间传递数据，使用Visual Basic照样能达到目的。
   	  那么，Lisp的编程优势体现在哪里呢？
   	* 语言的编程能力越强大，写出来的程序就越短（当然不是指字符数量，而是指独立的语法单位）。
   	  代码的数量很重要，因为开发一个程序耗费的时间，主要取决于程序的长度。如果同一个软件，一种语言写出来的代码比另一种语言长三倍，这意味着你开发它耗费的时间也会多三倍。而且即使你多雇佣人手，也无助于减少开发时间，因为当团队规模超过某个门槛时，再增加人手只会带来净损失。Fred Brooks在他的名著《人月神话》（The Mythical Man-Month）中，描述了这种现象，我的所见所闻印证了他的说法。
   	  如果使用Lisp语言，能让程序变得多短？以Lisp和C的比较为例，我听到的大多数说法是C代码的长度是Lisp的7倍到10倍。但是最近，New Architect杂志上有一篇介绍ITA软件公司的文章，里面说"一行Lisp代码相当于20行C代码"，因为此文都是引用ITA总裁的话，所以我想这个数字来自ITA的编程实践。 如果真是这样，那么我们可以相信这句话。ITA的软件，不仅使用Lisp语言，还同时大量使用C和C++，所以这是他们的经验谈。
	  根据上面的这个数字，如果你与ITA竞争，而且你使用C语言开发软件，那么ITA的开发速度将比你快20倍。如果你需要一年时间实现某个功能，它只需要不到三星期。反过来说，如果某个新功能，它开发了三个月，那么你需要五年才能做出来。
	  你知道吗？上面的对比，还只是考虑到最好的情况。当我们只比较代码数量的时候，言下之意就是假设使用功能较弱的语言，也能开发出同样的软件。但是事实上，程序员使用某种语言能做到的事情，是有极限的。如果你想用一种低层次的语言，解决一个很难的问题，那么你将会面临各种情况极其复杂、乃至想不清楚的窘境。
	  所以，当我说假定你与ITA竞争，你用五年时间做出的东西，ITA在Lisp语言的帮助下只用三个月就完成了，我指的五年还是一切顺利、没有犯错误、也没有遇到太大麻烦的五年。事实上，按照大多数公司的实际情况，计划中五年完成的项目，很可能永远都不会完成。
   	  我承认，上面的例子太极端。ITA似乎有一批非常聪明的黑客，而C语言又是一种很低层次的语言。但是，在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。
   	* 编程能力
   	  为了解释我所说的语言编程能力不一样，请考虑下面的问题。我们需要写一个函数，它能够生成累加器，即这个函数接受一个参数n，然后返回另一个函数，后者接受参数i，然后返回n增加（increment）了i后的值。
   	  Common Lisp的写法如下：
	  #+begin_src emacs-lisp :tangle yes
        (defun foo (n)
          (lambda (i) (incf n i)))
	  #+end_src
	  Ruby的写法几乎完全相同：
	  #+begin_src ruby
        def foo (n)
          lambda {|i| n += i }
        end
	  #+end_src
	  Perl 5的写法则是：
	  #+begin_src perl
        sub foo {
            my ($n) = @_;
            sub {$n += shift}
        }
	  #+end_src
	  这比Lisp和Ruby的版本，有更多的语法元素，因为在Perl语言中，你不得不手工提取参数。
	  Smalltalk的写法稍微比Lisp和Ruby的长一点：
	  #+begin_src sh
        foo: n
          |s|
          s := n.
          ^[:i| s := s+i. ]
	  #+end_src   	　　
	  因为在Smalltalk中，局部变量（lexical variable）是有效的，但是你无法给一个参数赋值，因此不得不设置了一个新变量，接受累加后的值。
	  Javascript的写法也比Lisp和Ruby稍微长一点，因为Javascript依然区分语句和表达式，所以你需要明确指定return语句，来返回一个值：
	  #+begin_src javascript
        function foo (n) {
            return function (i) {
                return n += i
            }
        }
	  #+end_src
   	  如果想把Lisp/Ruby/Perl/Smalltalk/Javascript的版本改成Python，你会遇到一些限制。因为Python并不完全支持局部变量，你不得不创造一种数据结构，来接受n的值。而且尽管Python确实支持函数数据类型，但是没有一种字面量的表示方式（literal representation）可以生成函数（除非函数体只有一个表达式），所以你需要创造一个命名函数，把它返回。最后的写法如下：
	  #+begin_src python
        def foo (n):
            s = [n]
            def bar (i):
                s[0] += i
                return s[0]
            return bar
	  #+end_src
	  Python用户完全可以合理地质疑，为什么不能写成下面这样：
	  #+begin_src python
        def foo (n):
            return lambda i: return n += i
	  #+end_src   	　　
	  或者：
	  #+begin_src python
        def foo (n):
            lambda i: n += i
	  #+end_src   	　　
	  我猜想，Python有一天会支持这样的写法。（如果你不想等到Python慢慢进化到更像Lisp，你总是可以直接......）
   	  在面向对象编程的语言中，你能够在有限程度上模拟一个闭包（即一个函数，通过它可以引用由包含这个函数的代码所定义的变量）。你定义一个类（class），里面有一个方法和一个属性，用于替换封闭作用域（enclosing scope）中的所有变量。这有点类似于让程序员自己做代码分析，本来这应该是由支持局部作用域的编译器完成的。如果有多个函数，同时指向相同的变量，那么这种方法就会失效，但是在这个简单的例子中，它已经足够了。
   	  Python高手看来也同意，这是解决这个问题的比较好的方法，写法如下：
	  #+begin_src python
        def foo (n):
            class acc:
                def _ _init_ _ (self, s):
                    self.s = s
                    def inc (self, i):
                        self.s += i
                        return self.s
                    return acc (n).inc
	  #+end_src   	　　
	  或者
	  #+begin_src python
        class foo:
            def _ _init_ _ (self, n):
                self.n = n
                def _ _call_ _ (self, i):
                    self.n += i
                    return self.n
	  #+end_src
	  我添加这一段，原因是想避免Python爱好者说我误解这种语言。但是，在我看来，这两种写法好像都比第一个版本更复杂。你实际上就是在做同样的事，只不过划出了一个独立的区域，保存累加器函数，区别只是保存在对象的一个属性中，而不是保存在列表（list）的头（head）中。使用这些特殊的内部属性名（尤其是__call__），看上去并不像常规的解法，更像是一种破解。
   	  在Perl和Python的较量中，Python黑客的观点似乎是认为Python比Perl更优雅，但是这个例子表明，最终来说，编程能力决定了优雅。Perl的写法更简单（包含更少的语法元素），尽管它的语法有一点丑陋。
   	  其他语言怎么样？前文曾经提到过Fortran、C、C++、Java和Visual Basic，看上去使用它们，根本无法解决这个问题。Ken Anderson说，Java只能写出一个近似的解法：
	  #+begin_src java
        public interface Inttoint {
            public int call (int i);
        }

        public static Inttoint foo (final int n) {
            return new Inttoint () {
                int s = n;
                public int call (int i) {
                    s = s + i;
                    return s;
                }
            };
        }
	  #+end_src   	　　
	  这种写法不符合题目要求，因为它只对整数有效。
   	  当然，我说使用其他语言无法解决这个问题，这句话并不完全正确。所有这些语言都是图灵等价的，这意味着严格地说，你能使用它们之中的任何一种语言，写出任何一个程序。那么，怎样才能做到这一点呢？就这个小小的例子而言，你可以使用这些不那么强大的语言，写一个Lisp解释器就行了。
	  这样做听上去好像开玩笑，但是在大型编程项目中，却不同程度地广泛存在。因此，有人把它总结出来，起名为"格林斯潘第十定律"（Greenspun's Tenth Rule）：
	  *"任何C或Fortran程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是bug的、运行速度很慢的Common Lisp实现。"*
	  如果你想解决一个困难的问题，关键不是你使用的语言是否强大，而是好几个因素同时发挥作用（a）使用一种强大的语言，（b）为这个难题写一个事实上的解释器，或者（c）你自己变成这个难题的人肉编译器。在Python的例子中，这样的处理方法已经开始出现了，我们实际上就是自己写代码，模拟出编译器实现局部变量的功能。
	  这种实践不仅很普遍，而且已经制度化了。举例来说，在面向对象编程的世界中，我们大量听到"模式"（pattern）这个词，我觉得那些"模式"就是现实中的因素（c），也就是人肉编译器。 当我在自己的程序中，发现用到了模式，我觉得这就表明某个地方出错了。程序的形式，应该仅仅反映它所要解决的问题。代码中其他任何外加的形式，都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，也经常提醒我，自己正在手工完成的事情，本应该写代码，通过宏的扩展自动实现。
*** C语言取当前系统时间
	#+BEGIN_SRC C
      time_t nowtime;
      struct tm *timeinfo;
      time( &nowtime );
      timeinfo = localtime( &nowtime );
      printf("年：%d 月：%d 日：%d\n", timeinfo->tm_year + 1900, timeinfo->tm_mon + 1, timeinfo->tm_mday);
	#+END_SRC
** Source
*** GitHub
**** [[https://github.com/TencentOpen][腾讯开源库]]
	 * [ ] [[https://github.com/ruleless/behaviac][腾讯提供的行为树的一种解决方案]]
	 * [ ] [[https://github.com/ruleless/TscanCode][TscanCode 静态代码扫描工具]]
**** [[https://github.com/ruleless][ruleless]]												  :kbe:snail:src:
	 * [ ] [[git@github.com:ruleless/snail.git][snail]]
	 * [ ] [[https://github.com/ruleless/UnrealEngine][UnrealEngine]]
	 * [ ] [[https://github.com/ruleless/UnrealTournament][UnrealTournament]]
	   虚幻竞技场
	 * [ ] [[https://github.com/ruleless/sigar][sigar]]
	   System Information Gatherer And Reporter http://sigar.hyperic.com/
	 * [ ] [[https://github.com/ruleless/openssl][openssl]]
	 * [ ] [[https://github.com/ruleless/cocos2d-x][cocos2d-x]]
	 * [ ] [[https://github.com/ruleless/kbengine][kbengine]]
	   A MMOG engine of server.
	 * [ ] [[https://github.com/ruleless/kbengine_unity3d_warring][kbengine_unity3d_warring]]
	 * [ ] [[https://github.com/ruleless/ogre][orge]]
** Git																	:git:
*** .git目录结构
**** .git目录下的重要文件
     |--------+------------------------+---------------------------------------------------|
     | 文件名 | 文件内容               | 文件作用                                          |
     |--------+------------------------+---------------------------------------------------|
     | config | 远程主机信息；分支信息 | Git配置，用于描述远程主机地址、分支以及子模块信息 |
     | index  | 二进制文件             | 对应Git的暂存区                                   |
     | HEAD   | ref: refs/heads/master | 对应当前本地分支（或概念模型中的版本库）          |
     |--------+------------------------+---------------------------------------------------|
**** .git目录下的重要目录
     |----------+--------------------------|
     | 目录名   | 描述                     |
     |----------+--------------------------|
     | refs/    | 该目录有三个子目录：     |
     |          | *heads* : 本地分支指针   |
     |          | *remotes* : 远程分支指针 |
     |          | *tags* :                 |
     | objects/ | Git对象库                |
     | logs/    |                          |
     |----------+--------------------------|
*** Git远程操作
**** Git远程命令概览
	 1. git clone
	 2. git remote
	 3. git fetch
	 4. git pull
	 5. git push
**** Git远程仓库与本地仓库的关系图
	 file:./Res/Git/GitRepRelation.png
**** git clone
	 远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令：
	 #+BEGIN_SRC sh
       $ git clone <版本库的网址>
	 #+END_SRC
	 比如，克隆jQuery的版本库：
	 #+BEGIN_SRC sh
       $ git clone https://github.com/jquery/jquery.git
	 #+END_SRC
	 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数：
	 #+BEGIN_SRC sh
       $ git clone <版本库的网址> <本地目录名>
	 #+END_SRC
	 git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子：
	 #+BEGIN_SRC sh
       $ git clone http[s]://example.com/path/to/repo.git/
       $ git clone ssh://example.com/path/to/repo.git/
       $ git clone git://example.com/path/to/repo.git/
       $ git clone /opt/git/project.git
       $ git clone file:///opt/git/project.git
       $ git clone ftp[s]://example.com/path/to/repo.git/
       $ git clone rsync://example.com/path/to/repo.git/
	 #+END_SRC
	 SSH协议还有另一种写法：
	 #+BEGIN_SRC sh
       $ git clone [user@]example.com:path/to/repo.git/
	 #+END_SRC
	 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。
**** git remote
     为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机：
	 #+BEGIN_SRC sh
       $ git remote
       origin
	 #+END_SRC
	 使用-v选项，可以参看远程主机的网址：
	 #+BEGIN_SRC sh
       $ git remote -v
       origin  git@github.com:jquery/jquery.git (fetch)
       origin  git@github.com:jquery/jquery.git (push)
	 #+END_SRC
	 上面命令表示，当前只有一台远程主机，叫做origin，后面跟随了它的网址。
	 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定：
	 #+BEGIN_SRC sh
       $ git clone -o jQuery https://github.com/jquery/jquery.git
       $ git remote
       jQuery
	 #+END_SRC
	 上面命令表示，克隆的时候，指定远程主机叫做jQuery。
	 1) git remote show命令加上主机名，可以查看该主机的详细信息。
		#+BEGIN_SRC sh
          $ git remote show <主机名>
		#+END_SRC
	 2) git remote add命令用于添加远程主机。
		#+BEGIN_SRC sh
          $ git remote add <主机名> <网址>
		#+END_SRC
	 3) git remote rm命令用于删除远程主机。
		#+BEGIN_SRC sh
          $ git remote rm <主机名>
		#+END_SRC
	 4) git remote rename命令用于远程主机的改名。
		#+BEGIN_SRC sh
          $ git remote rename <原主机名> <新主机名>
		#+END_SRC
**** git fetch
	 此命令的作用是：将远程分支的更新取回本地
	 #+BEGIN_SRC sh
       $ git fetch <远程主机名>
	 #+END_SRC
	 上面命令将某个远程主机的更新，全部取回本地。
	 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。
	 #+BEGIN_SRC sh
       $ git fetch <远程主机名> <分支名>
	 #+END_SRC
	 比如，取回origin主机的master分支。
	 #+BEGIN_SRC sh
       $ git fetch origin master
	 #+END_SRC
	 所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如origin主机的master，就要用origin/master读取。
	 git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。
	 #+BEGIN_SRC sh
       $ git branch -r
       origin/master
       $ git branch -a
       * master
       remotes/origin/master
	 #+END_SRC
	 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。
	 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。
	 #+BEGIN_SRC sh
       $ git checkout -b newBrach origin/master
	 #+END_SRC
	 上面命令表示，在origin/master的基础上，创建一个新分支。
	 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。
	 #+BEGIN_SRC sh
       $ git merge origin/master
	 #+END_SRC
	 或者
	 #+BEGIN_SRC sh
       $ git rebase origin/master
	 #+END_SRC
	 上面命令表示在当前分支上，合并origin/master。
**** git pull
     git pull命令的作用是：将远程分支的更新取回本地，再与本地的指定分支合并。它的完整格式稍稍有点复杂。
	 #+BEGIN_SRC sh
       $ git pull <远程主机名> <远程分支名>:<本地分支名>
	 #+END_SRC
	 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。
	 #+BEGIN_SRC sh
       $ git pull origin next:master
	 #+END_SRC
	 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。
	 #+BEGIN_SRC sh
       $ git pull origin next
	 #+END_SRC
	 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。
	 #+begin_src sh
       $ git fetch origin
       $ git merge origin/next
	 #+end_src
	 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动"追踪"origin/master分支。
	 Git也允许手动建立追踪关系。
	 #+begin_src sh
       $ git branch --set-upstream master origin/next
	 #+end_src
	 上面命令指定master分支追踪origin/next分支。
	 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。
	 #+begin_src sh
       $ git pull origin
	 #+end_src
	 上面命令表示，本地的当前分支自动与对应的origin主机"追踪分支"（remote-tracking branch）进行合并。
	 如果当前分支只有一个追踪分支，连远程主机名都可以省略。
	 #+begin_src sh
       $ git pull
	 #+end_src
	 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。
	 如果合并需要采用rebase模式，可以使用--rebase选项。
	 #+begin_src sh
       $ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>
	 #+end_src
	 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。
	 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。
	 #+begin_src sh
       $ git pull -p
	 #+end_src
	 它等同于下面的命令：
	 #+begin_src sh
       $ git fetch --prune origin
       $ git fetch -p
	 #+end_src
**** git push
	 git push命令用于将本地分支的更新，推送到远程分支。它的格式与git pull命令相仿。
	 #+begin_src sh
       $ git push <远程主机名> <本地分支名>:<远程分支名>
	 #+end_src
	 注意，分支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。
	 如果省略远程分支名，则表示将本地分支推送到与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。
	 #+begin_src sh
       $ git push origin master
	 #+end_src
	 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。
	 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。
	 #+begin_src sh
       $ git push origin :master
	 #+end_src
	 它等同于：
	 #+begin_src sh
       $ git push origin --delete master
	 #+end_src
	 上面命令表示删除origin主机的master分支。
	 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。
	 #+begin_src sh
       $ git push origin
	 #+end_src
	 上面命令表示，将当前分支推送到origin主机的对应分支。
	 如果当前分支只有一个追踪分支，那么主机名都可以省略。
	 #+begin_src sh
       $ git push
	 #+end_src
	 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。
	 #+begin_src sh
       $ git push -u origin master
	 #+end_src
	 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。
	 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。
	 #+begin_src sh
       $ git config --global push.default matching
	 #+end_src
	 或者
	 #+begin_src sh
       $ git config --global push.default simple
	 #+end_src
	 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。
	 #+begin_src sh
       $ git push --all origin
	 #+end_src
	 上面命令表示，将所有本地分支都推送到origin主机。
	 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。
	 #+begin_src sh
       $ git push --force origin
	 #+end_src
	 上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。
	 最后，git push不会推送标签（tag），除非使用--tags选项。
	 #+begin_src sh
       $ git push origin --tags
	 #+end_src
**** Fork之后与源同步
	 可按如下步骤同步源的最新代码：
	 1. 将源仓库添加到远程仓库列表(git remote add)
	 2. 从源仓库获取最新代码
	 3. 将新更新下来的分支合并到master分支
	 #+BEGIN_SRC c
       git remote add source git@github.com:source/proj.git
       git fetch source
       git merge source/master
	 #+END_SRC
*** Git分支
**** 分支查看
	 * 查看本地分支
	   #+BEGIN_SRC sh
         $ git branch
         * master
	   #+END_SRC
	 * 查看远程分支
	   #+BEGIN_SRC sh
         $ git branch -r
           kbengine/master
           origin/HEAD -> origin/master
           origin/master
	   #+END_SRC
	 * 查看所有分支
	   #+BEGIN_SRC sh
         $ git branch -a
         * master
           remotes/kbengine/master
           remotes/origin/HEAD -> origin/master
           remotes/origin/master
	   #+END_SRC
	 * 创建分支
	   #+BEGIN_SRC sh
         $ git branch <分支名>
	   #+END_SRC
	 * 删除本地分支
	   #+BEGIN_SRC sh
         $ git branch -d <分支名>
	   #+END_SRC
	 * 切换分支
	   #+BEGIN_SRC sh
         git checkout <分支名>
	   #+END_SRC
**** 分支合并
* Articles
** MMOG
   * [[https://developer.valvesoftware.com/wiki/Main_Page][Source Engine]]
	 1. [ ] [[https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization][网络延时补偿]]
	 2. [ ] [[https://developer.valvesoftware.com/wiki/Lag_compensation][Lag compensation]]
	 3. [ ] [[https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking][Source Multiplayer Networking]]
