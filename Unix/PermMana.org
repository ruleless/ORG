* Unix权限管理
  权限管理实际就是身份认证和访问权限校验，被授权的用户可获得权限，反之，则否。
  在 Unix 中用到权限管理的场合包括：
  1. 登录
  2. 进程对文件的存取访问
  第1点暂不予讨论。
  + 身份认证的过程实际就是：“系统”校验“主体”是否符合“客体”所期望的身份的过程。在“进程对文件的存取访问”的身份认证过程中，内核担当“系统”角色，进程为“主体”，文件则为“客体”。
	那么，认证的依据是什么？主客双方都需要提供某种类型的身份凭证！在“进程对文件的存取访问”的认证过程中，进程提供的身份凭证是有效用户ID和有效组ID；文件提供的凭证则是属主用户ID和属主组ID。
  + 在提供差异化权限管理的系统中完成身份认证只是第一步，“客体”对不同“主体”的开放程度可能是不同的，如果没有访问权限校验的过程，则无法提供这种特性。访问权限校验是指：在指定身份下，“客体”是否可满足特定类型的访问申请。
* 进程权限
  任意Unix进程可有如下“身份”：
  + 实际用户ID、有效用户ID、保存的设置用户ID
  + 实际组ID、有效组ID、保存的设置组ID
  这些“身份“的访问控制函数总结如下：
  #+BEGIN_SRC c
	#include <unistd.h>

	uid_t getuid( ); // 获取实际用户ID
	uid_t geteuid( ); // 获取有效用户ID
	int setuid( uid_t uid ); // 设置实际用户ID和有效用户ID
	int seteuid( uid_t uid ); // 设置有效用户ID

	gid_t getgid( ); // 获取实际组ID
	gid_t getegid( ); // 获取有效组ID
	int setgid( gid_t gid ); // 设置实际组ID和有效组ID
	int setegid( gid_t gid ); // 设置有效组ID
  #+END_SRC
  setuid 和 setgid 可按规则设置调用进程的实际和有效“身份”，这些规则如下：
  + 以 setuid 为例：
	1. 若调用进程具有超级用户特权[fn:1]，则将调用进程的实际用户ID、有效用户ID、保存的设置用户ID都设为uid
	2. 若调用进程的实际用户ID或保存的设置用户ID等于参数uid，则将调用进程的有效用户ID设置为uid
  + setgid 的规则与 setuid 类似
* 文件权限
  文件跟权限管理相关的两条属性分别是：
  1. 属主，它指明了文件的归属，包括：
	 + 用户ID
	 + 组ID
  2. 访问控制权限，它指明了文件对不同身份的进程所允许的访问操作，共包括三组：
	 1. 对所属用户所允许的访问操作： -rwx
	 2. 对所属组所允许的访问操作：   ----rwx
	 3. 对其他用户所允许的访问操作： -------rwx
* 进程对文件的存取访问的权限校验过程
  1. 若进程有效用户ID为0，则允许访问
  2. 若进程有效用户ID等于文件所属者用户ID，则按用户访问权限位进行访问
  3. 若进程有效组ID等于文件所属者组ID，则按组访问权限位进行访问
  4. 若以上都不匹配，则按其他用户访问权限位进行访问

* Footnotes

[fn:1] 即，调用进程的有效用户ID等于0
