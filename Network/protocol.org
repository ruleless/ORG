* TCP/IP协议工作原理简述
** 概要
   协议是什么？协议是一组为完成特定需求或功能而定义的标准通讯格式。协议是服务于具体需求或功能的，它不能独立存在。

   制定TCP/IP协议的目的是为了解决主机互联以及互联的主机上的应用通讯的问题。TCP/IP协议共有四层：应用层、传输层、网络层、链路层。应用层实际就是我们的应用程序，对于非具体应用而言这一层的协议是未定义的，需要我们自己根据我们具体的业务模型来制定。传输层桥接应用层和网络层，向下为我们的应用层数据填入端口标识，向上根据端口标识往各个应用分发数据包。网络层主要的功能是逻辑选路，确保我们的数据包能到达指定的目的地。链路层负责往/从有直接物理链路相连的主机或路由器发包/收包。

   TCP/IP协议是工作在主机或路由器上的，这一点很明显，因为网络拓扑中的实体除了主机(路由器)就是链路，链路当然不能运行我们的协议，它只能传输数据。当主机A中的a程序需要跟主机B中的b程序通讯的时候，A主机会根据TCP/IP协议往我们的原始数据包中依次塞入：TCP首部字段(假如应用程序基于TCP协议)、IP首部字段、以太网首部字段，最后形成的数据包我们称之为以太网数据帧，任何一台主机发送和接收的都只能是以太网数据帧；B主机收到相应的以太网数据帧后，会依次丢弃：以太网首部字段、IP首部字段、TCP首部字段，然后再将剩下的数据包交给b程序。现如今，很多复杂的应用程序也采用类似的思想对应用层协议进行分层。
** 应用层
   常见的应用层协议有：
   * echo            7/tcp(udp)
   * daytime         13/tcp(udp)
   * ftp             21/tcp(udp)
   * ssh             22/tcp(udp)
   * telnet          23/tcp(udp)
   * tftp            69/tcp(udp)
   * finger          79/tcp(udp)
   * http            80/tcp(udp)
   * https           443/tcp(udp)         # http protocol over TLS/SSL

   应用层协议与我们具体编写的应用相关，它是整个TCP/IP协议族的最上层协议，也是唯一由用户制定通讯格式的协议(标准委员会不能未卜先知)。数据传输一般是由应用层发起的，但它除了提供一个目标地址(域名或IP地址)之外，不涉及任何传输细节。应用层只专注于应用所属领域内的业务逻辑。
** 传输层
   工作在传输层的协议主要有TCP和UDP协议。传输层主要负责主机内的应用层数据包的收取和派发工作。应用层组好包后将数据包交给传输层，传输层经过一定的处理(填充TCP或UDP首部字段)之后，再转交给IP协议模块；传输层从下层IP模块收包时，去掉本层相关的首部字段，再将数据包派发给各个应用程序。由于传输层服务的对象是主机内的所有应用程序，所以它需要特定的手段来区分不同的应用程序，此即，端口。

   只做上面这些事情似乎有点少！对，标准委员会的人也是这么想的。所以，除了上面的核心业务之外，不同的传输层协议还提供了点增值服务。例如：TCP提供可靠的数据传输业务；UDP提供一对多的广播业务。

   传输层同样不清楚传输细节，它只对上层应用层负责。
** 网络层
   工作在网络层的协议主要有：IP协议、ICMP以及IGMP协议。其中IP协议最为重要，ICMP和IGMP协议也得依赖IP协议来收发包。

   网络层的核心业务即是选路(确定数据包的下一跳)，在所有的网络层协议中，IP协议负责该核心业务，所以我们有时候也直接用IP协议来指代网络层。在处理上层传输层和下层链路层发来的数据包时，IP协议的行为是不一样的，前者，仅仅填入本机和目的端IP地址；后者，对于本应交给本机的数据包提交给上层传输层，对于非交给本机的数据包也为它们指明下一跳(需特殊配置主机)。可以看到IP协议不仅对本机尽职尽责，同时也颇具助人为乐的精神，事实上，这种助人为乐的精神正是整个TCP/IP协议得以正常运转的核心。

   IP协议为上层传输层下发的数据包或路过的数据包选好路后，它们并不亲自将包送达下一站，而是将它们交代给链路层去护送。
** 链路层
   工作在链路层的协议主要包括：Ethernet、IEEE 802、ARP、RARP等协议。链路层的核心功能是：1. 将数据包发送给有直接物理链路相连的主机(或路由器) 2. 从有直接物理链路相连的主机(或路由器)处收取数据。链路层执行的是实际的收发包工作，所以，它们只能往/从有直接物理链路相连的主机(或路由器)发送/收取数据，毕竟，物理规律总是得遵守的。

   链路层必须向物理链路上发送所有IP协议交代下来的数据包，必须将所有收到的数据包(以太网数据帧)交给IP协议处理。链路层是没有什么自主权的，不能擅自截留，不能擅自丢包，能做的仅仅是搬运，实实在在的搬砖工人。链路层也没什么智商，IP交给它的数据包虽然包含IP地址，但它却看不明白，它只认物理地址(即48位mac地址)。如果某个IP地址是它不久前去过的地方(ARP缓存)，那当要送包再去往该IP地址时，它直接就能送；否则，就得挨个问一遍，有则去，没有就算了。而且它也很容易被欺骗，网关就经常骗它。网关为什么要欺骗它呢？因为IP协议决定的下一跳不一定就在局域网中(即跟当前主机没有直接相连的物理链路)，而链路层工作能力有限，只能在局域网内发包，所以网关只好骗它说我就是目标地址的主机。
* TCP/IP协议分层
  [[./.Res/ProtocolLayer.png]]
  当 A 主机上的用户进程需要向 B 主机上的用户进程发送数据 i 时，假如用户进程是基于 TCP 的应用程序：i 先经过 TCP 协议模块，被填入 20 字节 TCP 首部字段，此时装入 TCP 首部字段的 i 被称为 TCP 报文；然后，经过 IP 层，被填入 20 字节 IP 首部字段，此时的 i 被称为 IP 数据报；之后 i 经由以太网驱动程序的处理，被填入 14 字节的以太网首部字段，此时的 i 被称为以太网数据帧，之后再被发送到物理链路上。当 B 主机收到已被封装为以太网数据帧的 i 时：其以太网驱动程序先取出 i 的以太网首部数据，判断其协议类型是 IP 数据报，于是就将拆分后的 IP 数据报 i 传给 IP 协议模块；IP 层同样也从 i 中取出 IP首部字段，判断其协议类型是 TCP，于是就将 剩余的 TCP 数据报传输给 TCP 协议模块；TCP 协议模块根据端口号将去除 TCP 首部字段的数据 i 分发给相应的用户进程。
* 链路层
** ARP地址解析协议
** RARP逆地址解析协议
* 网络层
** IP地址
*** IP地址分类
   	互联网上的IP地址共分为5类：

   	A类地址由7位网络地址和24位主机地址组成，形如：
   	| 0 | ******* | ************************ |

   	B类地址由14位网络地址和16位主机地址组成，形如：
   	| 10 | ************** | **************** |

   	C类地址由21位网络地址和8位主机地址组成，形如：
   	| 110 | ********************* | ******** |

   	D类地址用于多播，形如：
   	| 1110 | ******************************* |

   	E类地址用作备用，形如：
   	| 11110 | ****************************** |
*** 子网划分
   	现在所有的主机都要求支持子网编址，即，把主机号再拆分成一个子网号和一个主机号。

*** 特殊的IP地址
** IP协议
*** IP选路
**** 选路机制
**** 静态选路
**** 动态选路
** ICMP控制报文协议
*** 概要
   	ICMP控制报文协议的英文全称是：Internet Control Message Protocol。
*** ICMP查询报文
**** ICMP地址掩码请求/应答协议
**** ICMP时间戳请求/应答协议
**** ICMP回显请求/应答报文
*** ICMP差错报文
**** ICMP端口不可达差错报文
**** ICMP主机或网络不可达差错报文
**** ICMP重定向差错报文
* 传输层
** UDP 协议
** TCP 协议
*** TCP 连接的建立和终止
*** TCP 交互数据流
**** 概要
	 如果按照分组数量计算，约有一半的 TCP 报文段包含成块数据(如FTP、电子邮件和Usenet新闻)，另一半则包含交互数据(如Telnet和Rlogin)。如果按字节计算，则成块数据与交互数据的比例约为 90% 和 10%。这是因为成块数据的报文段长度基本上都是满长度，而交互数据则小得多。

	 TCP 需要同时处理这两类数据，但使用的处理算法则有所不同。对于交互数据，TCP 主要使用 *延时确认* 和 *Nagle算法* 减少网络上的 TCP 小分组数量；而对于成块数据，则主要使用 *滑动窗口协议* 和 *慢启动算法* 来控制流量，避免拥塞。
**** 经受时延的确认
	 通常 TCP 在接收到数据时并不立即发送 ACK，相反，它推迟发送，以便将 ACK 与需要沿该方向发送的数据一起发送(有时称这种现象为数据捎带 ACK)。绝大多数实现采用的时延为 200ms，也就是说，TCP 将以最大 200ms 的时延等待是否有数据一起发送。
**** Nagle 算法
	 Nagle 算法要求一个 TCP 连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。这些等待发送的小分组将被 TCP 收集，并在确认到来之时组装成一个分组发送出去。该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。而在希望减少小分组数目的低速广域网上，则会发送更少的分组。
**** 关闭 Nagle 算法
	 有时我们也需要关闭 Nagle 算法。一个典型的例子是 X窗口系统服务器：小消息(鼠标移动)必须无时延的发送，以便为进行某种操作的交互用户提供实时的反馈。

	 使用 Berkeley Socket API 的用户可通过 TCP_NODELAY 选项来关闭 Nagle 算法。
*** TCP 成块数据流
**** 滑动窗口
	 在 TCP 首部字段中有个 16 字节的 win 字段，它又被称为通告窗口，用于通告本端接收缓冲区的可用大小。对于发送方而言，它所发送到连接上的未经确认的分组字节不能超过对端通告的窗口大小。

	 在一个活跃的 TCP 连接上，通告窗口是动态变化的，我们用三个术语描述窗口左右边沿的运动：
	 1. 窗口左边沿向右边靠近称为 *窗口合拢* 。这种现象发生在接收方收到数据时。
	 2. 窗口右边沿向右移动称为 *窗口张开* 。这种现象发生在接收方应用进程从 TCP 接收缓冲区取出数据时。
	 3. 当右边沿向左边移动时，我们称之为 *窗口收缩* 。Host Requirements RFC 强烈建议不要使用这种方式。但 TCP 必须能够在某一端产生这种情况时进行处理。
**** 慢启动算法
	 慢启动算法协调新分组进入网络的速率与另一端返回确认的速率。

	 慢启动算法为发送方的 TCP 增加了另一个窗口：拥塞窗口(congestion window)，记为 cwnd。当与另一个网络的主机建立 TCP 连接时，拥塞窗口被初始化为 1 个报文段(即另一端通告的报文段大小:mss)。每收到一个 ACK，拥塞窗口就增加一个报文段(cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加)。发送方取拥塞窗口与通告窗口中的最小字节作为发送上限。拥塞窗口时发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。

	 发送方开始时发送一个报文段，然后等待 ACK。当收到该 ACK 时，拥塞窗口从 1 增加到 2，即可以发送两个报文段。当收到这两个报文段的 ACK 时，拥塞窗口就增加为 4。这是一种指数式增长。
*** TCP 的超时和重传机制
**** TCP 定时器
	 对于每个 TCP 连接，TCP 管理 4 个不同的定时器：
     |------------------------+-----------------------------------------------------------------|
     | *定时器类型*           | *作用*                                                          |
     |------------------------+-----------------------------------------------------------------|
     | 重传定时器             | 当发送一个报文段时：                                            |
     |                        | 若该定时器处于关闭状态，则该会启动一个针对该报文的定时器;       |
     |                        | 当对端确认该报文后，关闭该定时器                                |
     |------------------------+-----------------------------------------------------------------|
     | 坚持定时器(persist)    | 当接收方关闭其窗口时，将启动该定时器定时探测接收方窗口信息      |
     |------------------------+-----------------------------------------------------------------|
     | 保活定时器(keep alive) | 用于检测一个空闲连接的另一方何时崩溃或重启                      |
     |------------------------+-----------------------------------------------------------------|
     | 2MSL 定时器            | 在连接的一方执行主动关闭进入 TIME_WAIT 状态时，将启动该定时器； |
     |                        | 以防本端发送的最后一个 ACK 丢失，收到对端 FIN 时再次发送 ACK    |
     |------------------------+-----------------------------------------------------------------|
**** 重传间隔
***** 最初的超时重传间隔时间计算
****** 名词解释
	   * R:   RTT(Round-Trip Time)
	   * M:   最近一次测量到的 RTT
	   * α:   插值因子，取值为 0.9
	   * β:   推荐值为 2 的时延离散因子
	   * RTO: 重传超时时间(Retransmission Timeout)
****** 重传间隔计算
	   *R = αR + (1-α)M* 每次测量到新的 RTT 即 M 时，R 的值将被更新，这个新的估计值 90% 来自前一个估计， 10% 则取自新的测量。

	   最初使用的超时重传间隔: *RTO = βR* 。[Jacobson 1988] 详细分析了在 RTT 变化范围很大时，使用这个方法无法跟上这种变化，从而引起不必要的重传。正如 Jacobson 所描述的那样，当网络已处于饱和状态时，不必要的重传会增加网络的负载，对网络而言这就像火上浇油一样。
***** 新的超时重传间隔计算算法
****** 名词解释
	   * A:   被平滑的 RTT
	   * M:   最近一次测量到的 RTT
	   * Err: M-A
	   * D:   被平滑的均值偏差
	   * RTO: 重传超时时间
	   * g:   取值0.125
	   * h:   偏差增益，取值0.25
****** 重传间隔计算
	   * Err = M - A
	   * A = A + gErr
	   * D = D + h(|Err|-D)
	   * RTO = A + 4D
****** Karn 算法
	   在一个分组重传时会产生这样一个问题：假定一个分组被发送。当超时发生时，RTO 正在进行退避，分组以更长的 RTO 进行重传，然后收到一个确认。那么这个 ACK 是针对第一个分组的还是针对第二个分组呢？这就是所谓的重传多义性问题。
**** 拥塞避免算法
	 拥塞避免算法是一种处理丢失分组的方法。该算法假定由于分组受到损坏引起的丢失时非常少的，因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：发生超时和收到重复的确认。

	 拥塞避免算法和慢启动算法是两个目的不同的、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来做到这一点。在实际中这两个算法通常一起实现。

	 拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口变量(cwnd)和一个慢启动门限(ssthresh)。算法流程如下：
	 1) 对一个给定的连接，初始化 cwnd 为 1 个报文段， ssthresh 为 65535 个字节。
	 2) TCP 输出例程的输出不能超过 cwnd 和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。
	 3) 当拥塞发生时(超时或收到重复确认)， ssthresh 被设置为当前窗口大小的一半(cwnd 和接收方通告窗口的小的最小值，但最少为 2 个报文段)。此外，如果是超时引起了拥塞，则 cwnd 被设置为 1 个报文段(慢启动的初始值)。
	 4) 当新的数据被对方确认时，就增加 cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果 cwnd <= ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动算法初始时设置 cwnd 为一个报文段，此后每收到一个确认就加 1；拥塞避免算法要求每次收到一个确认时将 cwnd 增加 1/cwnd。与与慢启动的指数式增长比起来，这是一种 additive increase。我们希望在一个往返时间内最多为 cwnd 增加 1 个报文段，而慢启动将根据这个往返时间中所收到的确认的个数增加 cwnd。
**** 快速重传和快速恢复算法
	 在 TCP 的一端收到一个失序的报文段时，TCP 需要立即产生一个重复的 ACK，这个重复的 ACK 不应该被延迟，该重复的 ACK 的目的在于告诉对端我们收到一个失序的报文段，希望对端重传。

	 由于我们不知道一个重复的 ACK 是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的 ACK 到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的 ACK 之前，只可能产生 1~2 个重复的 ACK。如果一连收到 3 个或 3 个以上的重复的 ACK， 就非常可能是一个报文段丢失了。于是，我们就重传丢失的数据报文段，而无需等待超时定时器溢出，这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法，这就是快速恢复算法。

	 快速重传和快速恢复算法的执行流程如下：
	 1) 当收到第 3 个重复的 ACK 时，执行：ssthresh = cwnd/2; cwnd = ssthresh+3mss; 并重传丢失的分组。
	 2) 每次收到另一个重复的 ACK 时，cwnd 增加 1 个报文段大小并发送 1 个分组(如果新的 cwnd 允许发送)。
	 3) 当下一个确认新数据的 ACK 到达时，设置 cwnd 为 ssthresh (在第 1 步中设置的值)。这个 ACK 应该是在进行重传后的一个往返时间内对步骤 1 中重传的确认。另外，这个 ACK 也应该是对丢失的分组和收到的第 1 个重复的 ACK 之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。
**** ICMP 差错
	 一个接收到的主机不可达或网络不可达差错实际上都被忽略，因为这两个差错都被认为是短暂现象。这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定地切换到另一个替换路由。在这个过程中就可能发生这两个 ICMP 差错中的一个，但是 TCP 连接并不被关闭。相反，TCP 试图发送引起该差错的数据，尽管最终有可能会超时。当前基于 Berkeley 的实现记录发生的 ICMP 差错，如果连接超时，ICMP 差错被转换为一个更合适的差错码而不是“连接超时”。
*** TCP 坚持定时器
**** TCP 坚持定时器存在的意义
	 TCP 通过让接收方指明希望从发送方接收的数据字节数(即窗口大小)来进行流量控制。如果窗口大小为 0 会发生什么情况呢？这将有效地阻止发送方传送数据，直达窗口变为非 0 为止。当接收方通告窗口为 0 时，发送方不再向接收方发送数据，当接收方窗口张开时，接收方需要通过 ACK 分组告知发送方新的窗口大小。但 TCP 不对 ACK 报文进行确认，TCP 只确认哪些包含数据的 ACK 报文段。如果一个确认丢失了，则双方就有可能因为等待对方而使连接超时终止。为防止这种死锁现象发生，发送方使用坚持定时器来周期性地向对方查询，以便发现窗口是否已增大。这些从发送发出的报文段称为窗口探查(window probe)。
**** 糊涂窗口综合症
	 窗口探查报文总是包含 1 字节的数据，周期性的发送此报文可能导致少量数据通过连接进行交换。此即糊涂窗口综合症。该现象可发生在两端中的任何一端：接收方可以通告一个小的窗口(而不是一直等到有大的窗口时才通告)；而发送方也可以发送少量的数据(而不是等待其他数据以便发送一个大的报文段)。可以在任何一端采取措施避免出现糊涂窗口综合症的现象：
	 1) 接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口(可以为0)，除非窗口可以增加一个报文段大小(也就是对端的 mss)或者可以增加接收缓存的一半(不论实际有多少)。
	 2) 发送方避免糊涂窗口综合症的措施是只在下列条件至少满足一条时才发送数据：a) 可以发送一个满长度的报文段 b) 可以发送接收方初始接收缓存的一半大小的数据
*** TCP 保活定时器
* 应用层
